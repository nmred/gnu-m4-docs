# 初步介绍

第一章介绍什么是 GNU m4、m4 的发展历史、如何阅读与使用该文档、如何调用 m4 程序以及如何上报 bug。包含了阅读剩余文档的一些说明。

如下章节将详细的讲解 m4 语言特性

### 介绍 m4

m4 是一个宏处理器，某种意义上就是将输入复制写到输出，并且展开宏。宏不仅有内建类型的还有用户自定的宏，并且可以接受多个参数。后面仅需要宏展开即可，m4 有引入文件、运行 shell 命令、执行整形运算、文件处理、执行递归等等内建宏。m4 不仅可以作为编译器的前端处理模块还可以单纯作为宏处理器使用

m4 宏处理器在 UNIX 系统中运用比较广泛，并且是 POSIX 标准的一部分。通常只有少部分人知道它的存在，然而一旦知道了通常会变成忠实用户。通用的 GNU Autoconf 工具需要使用 GNU m4 来生成 `configure` 脚本, 也是许多人安装 m4 的原因。GNU m4 兼容 System V 系统的主要的 4 个版本，除了一些细微的区别。参考第十六章 [兼容性]()

有人发现 m4 会上上瘾，他们首先是使用 m4 解决一些简单的问题，随着越来越大的挑战学会编写使用复杂的宏定义解决问题，至此真的上瘾了，用户开始使用 m4 来解决任何的问题，有时发现专注于调试的时间以及大于解决问题本身的世界，对于强迫症的开发人员担心会影响身心健康的。

### 发展历史

宏语言是计算机历史中发明最早的语言。在 20 世纪 50 年代 Alan Perlis 建议宏语言独立于语言处理。相关技术如条件、宏递归以及用宏描述定义其他宏在贝尔实验室的 Doug McIlroy 论文[Macro Instruction Extensions of Compiler Languages](http://dx.doi.org/10.1145/367177.367223) 美国计算机学会通讯 3, 4 (1960), 214–20 中有描述.

另外一个重要的是 m4 的先驱 GPM, 参考 [A general purpose macrogenerator](http://dx.doi.org/10.1093/comjnl/8.3.225) 计算机学报 8, 3 (1965), 225–41 中描述。GPM 是对 David Gries 的 `Compiler Construction for Digital Computers, Wiley (1971)` 书的简要描述。 Strachey 是一个聪明的程序员：GPM 适合于 250 机器指令。
 
McIlroy 在 1968 年访问 Strachey 实验室是受到 GPM 的启发编写了一个处理器模型, 随后 McIlroy 和 Robert Morris 在贝尔实验室开发了一系列的进一步的模型. 随后 Andrew D.Hall 开发了 M6, 一个使用 Fortran 编写的运行与 Altran 计算机中的通用宏处理器。参考 [The M6 Macro Processor](http://cm.bell-labs.com/cm/cs/cstr/2.pdf) 计算科学技术报告. Bell Labs (1972),M6 源代码大概由 600 行 Fortran 源码组成，起名字和 m4 第一个字母一样。

Brian Kernighan 和 P.J Plauger 的书 `Software Tools` 书中描述并且实现了一个 Unix 宏处理器语言。受到 Dennis Ritchie 编写的一个运行在 AP-3 微型计算机中的  m3 的灵感.

Kernighan 和 Ritchie 随后都加入并专注于组织开发 m4, 描述了 [The M4 Macro Processor](http://wolfram.schneider.org/bsd/7thEdManVol2/m4/m4.pdf) 贝尔实验室 (1977), 此时仅有 21 个内建宏。


相比 GPM 纯粹简单， m4 意味着要处理错综复杂的现实问题：宏可以无需声明即可识别、跳过空格换行符、更多的内建宏来替代封装自定义宏，等等

起初 Kernighan 和 Plauger 的宏处理器包括 m3 ，应用在 Rational FORTRAN 预处理中，Ratfor 类似于 `cpp`。最后，m4 应用到了 Ratfor 、C 以及 Cobol 编程语言中。

`Ren ́e Seindal` 在 1990 年发布了他的 m4 的实现即 GNU m4，主要解决并移除了其他传统 m4 实现中很多人工的限制，如：最大行的长度、宏的大小、宏的个数等限制

随后在 1992 年教授 A.Dain Samples 描述并实现了一个演进版本 m5 在 : [User’s Guide to the M5 Macro Language: 2nd edition] .

`Franc ̧ois Pinard` 1992 年开始接管维护 GNU m, 知道 1994 年发布了 m4 1.4 版本，此时距离稳定办发布已经 10 年。与此同时 GNU Autoconf 决定使用 GNU m4 在其引擎下面，因为其他的 m4 实现都限制太多

2004 年 Paul Eggert 发布了 1.4.1 和 1.4.2 解决了 1.4 中长期未解决的一些 bug。随后在 2005 年, Gary V.Vaughan 收集了许多的 patch 通过互联网，并且发布了 1.4.3 和 1.4.4 版本。2006 年, Eric Blake  加入团队并且发布了 1.4.5，随后的几个版本一直到 2016 年的 1.4.18 

同时，m4 会继续有新的特性开发，例如动态模块加载，添加内建宏。当完成后 GNU m4 2.0 作为新的版本序列发布

### 问题与 BUG

如果你有关于 GNU m4 的问题或者发现 Bug, 请上报 issue。在上报 bug 前，确保你发现的 Bug 确实是一个 Bug。认真阅读文档看看是否可以实现你想要的。如果再做一些事情的时候说明的不够明白，也请上报，这说明是文档的 Bug

在上报 Bug 前尽量自己尝试的修复，尽可能的将输入文件最小化的复现问题。然后将输入文件和你期望的结果发给我们。也可以将你期望发送的行为发给我们，这样可以帮助我们快速定位是不是问题。

如果你有一个确切的问题，发送邮件到 `bug-m4@gnu.org`。请包含上使用 m4 的版本号。你可以用个运行 `m4 --version` 来获取。并且提供运行 m4 的平台信息

没有 Bug 我们也欢迎提建议。如果有的问题在文档中描述不清晰或者是一个复杂的特性，也请告知我们

### 使用手册说明

本手册包含了一些 m4 的使用示例，并且通过一些简单的标记来区分输入、输出以及 m4 的错误信息。例如正常字体并且加粗表示示例：

> **This is an example of an example!**

所有的输出前缀都用 `=>` 标记来区分输入和输出，错误消息使用 `[E]` 作为前缀。当显示命令行参数等示例，命令行前面有 `$` 作为前缀，假如你可以调用一个简单的 m4 处理，如下：

>**$ command line to invoke m4 **

>**Example of input line**

>**=> Output line from m4**

>**[E] and an error message**

`^D` 是结束输入文件的指令，`NL` 表示新一行的字符。大多数的示例都自己包含，并且你可以调用 `m4 -d` 输出相同的结果。事实上，本文档中的示例包含于 GNU m4 的测试用例中。一些例子假如位于解压安装包的当前目录，所以如果参照这些示例可能对你有所帮助

> **$ cd m4-1.4.18**

每个 m4 预定的宏描述，都会有一个宏调用原型显示，描述其名称及其参数等等,例如

>**example (string, [count = ‘1’], [argument]. . .) [Composite] **

> 这是一个示例的原型。不是真正存在一个 `example` 宏，但是该文档写法都类似此，该示例表示这是一个组合宏不是一个内建宏。其至少需要一个参数，字符串。在 m4 中在宏名称与圆括号间不能存在空格，除非是调用一个没有参数宏。方括号包括的 `count` 参数代表该参数是可选的。如果 `count` 省略则按照 `count` 为 `1` 处理。然而如果 `argument` 参数省略则默认是空字符串，空参数和省略参数不是一回事儿。例如： `example(‘a’)`、`example(‘a’,‘1’)`、和 `example(‘a’,‘1’,)` 行为都是相同的，`count` 参数都是 `1`。然而 `example(‘a’,)` 和 `example(‘a’,‘’)` 明确的说明参数 `count` 的值为空字符串。省略号`...` 代表该宏有附加参数，而不是省略的意思。

所有的宏参数都是字符串，但是有时会指定的理解含义，例如数字、文件名、规则表达式等等。该文档将说明每个宏的参数如何理解，并且当参数不能正确解析是会发生什么问题。除非有特殊的含义，一个数字参数会解析为十进制数字，即使以 `0` 开始；一个空字符串会解析为 `0` 而不会报错，最多和报 warning 提示

该文档中书写或用到的内建宏如果是英文单词则不会有连接符。这也是在 m4 中的原始写法
